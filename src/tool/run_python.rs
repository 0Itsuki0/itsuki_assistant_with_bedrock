use crate::model_constants::{BEDROCK_ASSISTANT_PYTHON, BEDROCK_ASSISTANT_PYTHON_KEY};

use super::{create_tool_result_block, ToDocument, ToolJsonSchema};

use core::str;
use std::{env, fs::{self, File}, io::Write, path::Path};
use anyhow::Result;
use aws_sdk_bedrockruntime::types::{ToolResultBlock, ToolResultContentBlock, ToolResultStatus};
use aws_smithy_types::Document;
use serde_json::json;


// READ_FILE tool
pub const RUN_PYTHON_NAME: &str = "RUN_PYTHON";
pub const RUN_PYTHON_DESCRIPTION: &str = "Run Python code for data analysis, data exploration, math, etc.";
pub fn run_python_schema() -> Result<Document> {
    let value = json!({
        "type": "object",
        "properties": {
            "title": {
                "type": "string",
                "description": "Short title (5 words max) for the code."
            },
            "description": {
                "type": "string",
                "description": "Short description for the code."
            },
            "code": {
                "type": "string",
                "description": "The code to run in its own context."
            },
            "path": {
                "type": "string",
                "description": "The path of the folder where the code sandbox should be created. It should be the same as all the artifacts generated by the code. Default to the current working directory. "
            },
        },
        "required": ["title", "description", "code", "path"],
    });
    let json_schema = value;
    let document = ToolJsonSchema::new(json_schema)?.to_document();
    Ok(document)
}

pub fn run_python(id: &str, input: &Document) -> Result<ToolResultBlock> {
    let input_object = match input.as_object() {
        Some(object) => object,
        None => {
            return create_tool_result_block(id, "failed to convert input to object", ToolResultStatus::Error)
        },
    };

    let path = match input_object.get("path") {
        Some(object) => {
            match object.as_string()  {
                Some(s) => s,
                None => {
                    return create_tool_result_block(id, "path to save the code is not a string.", ToolResultStatus::Error)
                },
            }
        },
        None => {
            return create_tool_result_block(id, "path to save the code is not provided", ToolResultStatus::Error)
        },
    };

    let code = match input_object.get("code") {
        Some(object) => {
            match object.as_string()  {
                Some(s) => s,
                None => {
                    return create_tool_result_block(id, "code is not a string.", ToolResultStatus::Error)
                },
            }
        },
        None => {
            return create_tool_result_block(id, "code is not provided", ToolResultStatus::Error)
        },
    };

    let title = match input_object.get("title") {
        Some(object) => {
            match object.as_string()  {
                Some(s) => s,
                None => {
                    return create_tool_result_block(id, "title is not a string.", ToolResultStatus::Error)
                },
            }
        },
        None => {
            return create_tool_result_block(id, "title for the code block is not provided", ToolResultStatus::Error)
        },
    };

    let description = match input_object.get("description") {
        Some(object) => {
            match object.as_string()  {
                Some(s) => s,
                None => {
                    return create_tool_result_block(id, "description is not a string.", ToolResultStatus::Error)
                },
            }
        },
        None => {
            return create_tool_result_block(id, "description for the code block is not provided", ToolResultStatus::Error)
        },
    };

    let mut path = Path::new(path);
    if path.extension().is_some() {
        path = match path.parent() {
            Some(path) => path,
            None => {
                return create_tool_result_block(id, "cannot get a path to save the image.", ToolResultStatus::Error)
            }
        }
    }
    if !path.to_str().unwrap_or("").is_empty() {
        match fs::create_dir_all(path) {
            Ok(_) => {},
            Err(err) => {
                return create_tool_result_block(id, &err.to_string(), ToolResultStatus::Error)
            }
        };
    }

    match open::that_detached(path) {
        Ok(_) => {},
        Err(_) => {},
    };

    let file_name = Path::new(&format!("{}.py", id)).to_owned();
    let file_path = path.join(file_name);

    let mut file = File::create(file_path.clone())?;

    let content = format!("#{}\n#{}\n\n{}", title, description, code);
    file.write_all(content.as_bytes())?;

    match open::that_detached(file_path.clone()) {
        Ok(_) => {},
        Err(_) => {},
    };

    let python = env::var(BEDROCK_ASSISTANT_PYTHON_KEY).unwrap_or(BEDROCK_ASSISTANT_PYTHON.to_owned());
    let output = match std::process::Command::new(python)
        .arg(file_path.clone())
        .output() {
            Ok(output) => {
                println!("{:?}", output);
                let string = match str::from_utf8(&output.stdout) {
                    Ok(string) => string.to_owned(),
                    Err(_) => "".to_owned(),
                };
                string
            },
            Err(err) => {
                println!("error running command: {}", err.to_string());
                return create_tool_result_block(id, &format!("error running command: {}", err.to_string()), ToolResultStatus::Error)
            },
        };

    let content = if output.is_empty() {
        "Code executed".to_owned()
    } else {
        format!("Code executed with output: {}", output)
    };
    let tool_result = ToolResultBlock::builder()
        .tool_use_id(id.to_owned())
        .content(ToolResultContentBlock::Text(content))
        .status(ToolResultStatus::Success)
        .build()?;
    Ok(tool_result)
}
